$date
	Wed Oct  4 17:55:01 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_ALU $end
$var wire 1 ! sign $end
$var wire 8 " result [7:0] $end
$var wire 1 # overflow $end
$var parameter 32 $ CLKT $end
$var parameter 32 % period $end
$var reg 8 & A [7:0] $end
$var reg 8 ' B [7:0] $end
$var reg 4 ( FN [3:0] $end
$var reg 1 ) clk $end
$scope module I_ALU $end
$var wire 8 * A [7:0] $end
$var wire 8 + B [7:0] $end
$var wire 4 , FN [3:0] $end
$var wire 1 ! sign $end
$var wire 9 - tmp [8:0] $end
$var wire 8 . result [7:0] $end
$var wire 1 # overflow $end
$var wire 8 / A_mod3 [7:0] $end
$var reg 9 0 ALU_Result [8:0] $end
$var reg 1 1 pn $end
$scope module my_mod3 $end
$var wire 8 2 mod_in [7:0] $end
$var wire 8 3 mod_out [7:0] $end
$var wire 1 ! sign_in $end
$var reg 4 4 i [3:0] $end
$var reg 8 5 mod3_v [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module tb_ALU_ctrl $end
$var wire 2 6 reg_ctrl [1:0] $end
$var wire 4 7 func [3:0] $end
$var parameter 32 8 CLKT $end
$var parameter 32 9 period $end
$var reg 1 : clk $end
$var reg 1 ; enter $end
$var reg 1 < rst_n $end
$var reg 1 = sign $end
$scope module I_ALU_CTRL $end
$var wire 1 : clk $end
$var wire 1 ; enter $end
$var wire 4 > func [3:0] $end
$var wire 2 ? reg_ctrl [1:0] $end
$var wire 1 < rst_n $end
$var wire 1 = sign $end
$var reg 2 @ i_reg [1:0] $end
$var reg 1 A last_enter $end
$var reg 1 B last_sign $end
$var reg 2 C next_i_reg [1:0] $end
$var reg 4 D next_state [3:0] $end
$var reg 4 E state [3:0] $end
$upscope $end
$upscope $end
$scope module tb_ALU_top $end
$var wire 8 F sev_seg [7:0] $end
$var wire 8 G anode [7:0] $end
$var parameter 32 H CLKT $end
$var parameter 32 I period $end
$var reg 1 J b_enter $end
$var reg 1 K b_sign $end
$var reg 1 L clk $end
$var reg 1 M rst_n $end
$var reg 8 N sw_in [7:0] $end
$scope module I_ALU_TOP $end
$var wire 1 J b_enter $end
$var wire 1 K b_sign $end
$var wire 1 L clk $end
$var wire 1 M rst_n $end
$var wire 8 O sw_in [7:0] $end
$var wire 1 P w_sign $end
$var wire 8 Q w_result [7:0] $end
$var wire 2 R w_reg_ctrl [1:0] $end
$var wire 1 S w_overflow $end
$var wire 4 T w_func [3:0] $end
$var wire 10 U w_bcd_digit [9:0] $end
$var wire 8 V sev_seg [7:0] $end
$var wire 8 W led_scancode_debug [7:0] $end
$var wire 1 X d_sign $end
$var wire 1 Y d_enter $end
$var wire 8 Z anode [7:0] $end
$var wire 8 [ B [7:0] $end
$var wire 8 \ A [7:0] $end
$scope module I_ALU $end
$var wire 1 P sign $end
$var wire 9 ] tmp [8:0] $end
$var wire 8 ^ result [7:0] $end
$var wire 1 S overflow $end
$var wire 4 _ FN [3:0] $end
$var wire 8 ` B [7:0] $end
$var wire 8 a A_mod3 [7:0] $end
$var wire 8 b A [7:0] $end
$var reg 9 c ALU_Result [8:0] $end
$var reg 1 d pn $end
$scope module my_mod3 $end
$var wire 8 e mod_out [7:0] $end
$var wire 1 P sign_in $end
$var wire 8 f mod_in [7:0] $end
$var reg 4 g i [3:0] $end
$var reg 8 h mod3_v [7:0] $end
$upscope $end
$upscope $end
$scope module I_ALU_CTRL $end
$var wire 1 L clk $end
$var wire 2 i reg_ctrl [1:0] $end
$var wire 1 M rst_n $end
$var wire 1 X sign $end
$var wire 4 j func [3:0] $end
$var wire 1 Y enter $end
$var reg 2 k i_reg [1:0] $end
$var reg 1 l last_enter $end
$var reg 1 m last_sign $end
$var reg 2 n next_i_reg [1:0] $end
$var reg 4 o next_state [3:0] $end
$var reg 4 p state [3:0] $end
$upscope $end
$scope module I_BINARY_TO_BCD $end
$var wire 8 q binary_in [7:0] $end
$var wire 10 r bcd_out [9:0] $end
$var reg 4 s i [3:0] $end
$var reg 12 t reg_bcd_out [11:0] $end
$upscope $end
$scope module I_REG_UPDATER $end
$var wire 1 L clk $end
$var wire 2 u reg_ctrl [1:0] $end
$var wire 1 M rst_n $end
$var wire 8 v sw_input [7:0] $end
$var wire 8 w B [7:0] $end
$var wire 8 x A [7:0] $end
$var reg 8 y r_A [7:0] $end
$var reg 8 z r_B [7:0] $end
$upscope $end
$scope module I_SEVEN_SEGMENT_DRIVER $end
$var wire 10 { BCD_digit [9:0] $end
$var wire 1 L clk $end
$var wire 8 | digit_anode [7:0] $end
$var wire 1 S overflow $end
$var wire 1 M rst_n $end
$var wire 8 } segment [7:0] $end
$var wire 1 P sign $end
$var wire 8 ~ led_out [7:0] $end
$var reg 4 !" routed_vals [3:0] $end
$var reg 32 "" segment_counter [31:0] $end
$var reg 8 #" segment_state [7:0] $end
$scope module my_converter $end
$var wire 4 $" BCD_digit [3:0] $end
$var wire 8 %" led_out [7:0] $end
$var reg 8 &" int_seven_segment_number [7:0] $end
$upscope $end
$upscope $end
$scope module enter_debouncer $end
$var wire 1 '" PB_idle $end
$var wire 1 J button_in $end
$var wire 1 Y button_out $end
$var wire 1 L clk $end
$var wire 1 M rst_n $end
$var wire 1 (" PB_cnt_max $end
$var reg 16 )" PB_cnt [15:0] $end
$var reg 1 *" PB_state $end
$var reg 1 +" PB_sync_0 $end
$var reg 1 ," PB_sync_1 $end
$upscope $end
$scope module sign_debouncer $end
$var wire 1 -" PB_idle $end
$var wire 1 K button_in $end
$var wire 1 X button_out $end
$var wire 1 L clk $end
$var wire 1 M rst_n $end
$var wire 1 ." PB_cnt_max $end
$var reg 16 /" PB_cnt [15:0] $end
$var reg 1 0" PB_state $end
$var reg 1 1" PB_sync_0 $end
$var reg 1 2" PB_sync_1 $end
$upscope $end
$upscope $end
$upscope $end
$scope module tb_binary_to_bcd $end
$var wire 10 3" bcd_out [9:0] $end
$var parameter 32 4" CLKT $end
$var parameter 32 5" period $end
$var reg 1 6" Clk $end
$var reg 1 7" Rst_n $end
$var reg 8 8" binary_in [7:0] $end
$scope module I_BINARY_TO_BCD $end
$var wire 8 9" binary_in [7:0] $end
$var wire 10 :" bcd_out [9:0] $end
$var reg 4 ;" i [3:0] $end
$var reg 12 <" reg_bcd_out [11:0] $end
$upscope $end
$upscope $end
$scope module tb_reg_updater $end
$var wire 8 =" B [7:0] $end
$var wire 8 >" A [7:0] $end
$var parameter 32 ?" CLKT $end
$var parameter 32 @" period $end
$var reg 1 A" clk $end
$var reg 2 B" reg_ctrl [1:0] $end
$var reg 1 C" rst_n $end
$var reg 8 D" sw_input [7:0] $end
$scope module I_REG_UPDATER $end
$var wire 8 E" A [7:0] $end
$var wire 8 F" B [7:0] $end
$var wire 1 A" clk $end
$var wire 2 G" reg_ctrl [1:0] $end
$var wire 1 C" rst_n $end
$var wire 8 H" sw_input [7:0] $end
$var reg 8 I" r_A [7:0] $end
$var reg 8 J" r_B [7:0] $end
$upscope $end
$upscope $end
