$date
	Tue Oct  3 13:56:38 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_ALU $end
$var wire 1 ! sign $end
$var wire 8 " result [7:0] $end
$var wire 1 # overflow $end
$var parameter 32 $ CLKT $end
$var parameter 32 % period $end
$var reg 8 & A [7:0] $end
$var reg 8 ' B [7:0] $end
$var reg 4 ( FN [3:0] $end
$var reg 1 ) clk $end
$scope module I_ALU $end
$var wire 8 * A [7:0] $end
$var wire 8 + B [7:0] $end
$var wire 4 , FN [3:0] $end
$var wire 8 - result [7:0] $end
$var wire 1 ! sign $end
$var wire 9 . tmp [8:0] $end
$var wire 1 # overflow $end
$var reg 8 / ALU_Result [7:0] $end
$var reg 1 0 pn $end
$upscope $end
$upscope $end
$scope module tb_ALU_ctrl $end
$var wire 2 1 reg_ctrl [1:0] $end
$var wire 4 2 func [3:0] $end
$var parameter 32 3 CLKT $end
$var parameter 32 4 period $end
$var reg 1 5 clk $end
$var reg 1 6 enter $end
$var reg 1 7 rst_n $end
$var reg 1 8 sign $end
$scope module I_ALU_CTRL $end
$var wire 1 5 clk $end
$var wire 1 6 enter $end
$var wire 4 9 func [3:0] $end
$var wire 2 : reg_ctrl [1:0] $end
$var wire 1 7 rst_n $end
$var wire 1 8 sign $end
$var reg 2 ; i_reg [1:0] $end
$var reg 2 < next_i_reg [1:0] $end
$var reg 4 = next_state [3:0] $end
$var reg 4 > state [3:0] $end
$upscope $end
$upscope $end
$scope module tb_binary_to_bcd $end
$var wire 10 ? bcd_out [9:0] $end
$var parameter 32 @ CLKT $end
$var parameter 32 A period $end
$var reg 1 B Clk $end
$var reg 1 C Rst_n $end
$var reg 8 D binary_in [7:0] $end
$scope module I_BINARY_TO_BCD $end
$var wire 8 E binary_in [7:0] $end
$var wire 10 F bcd_out [9:0] $end
$var reg 4 G i [3:0] $end
$var reg 12 H reg_bcd_out [11:0] $end
$upscope $end
$upscope $end
$scope module tb_reg_updater $end
$var wire 8 I B [7:0] $end
$var wire 8 J A [7:0] $end
$var parameter 32 K CLKT $end
$var parameter 32 L period $end
$var reg 1 M clk $end
$var reg 2 N reg_ctrl [1:0] $end
$var reg 1 O rst_n $end
$var reg 8 P sw_input [7:0] $end
$scope module I_REG_UPDATER $end
$var wire 8 Q A [7:0] $end
$var wire 8 R B [7:0] $end
$var wire 1 M clk $end
$var wire 2 S reg_ctrl [1:0] $end
$var wire 1 O rst_n $end
$var wire 8 T sw_input [7:0] $end
$var reg 8 U r_A [7:0] $end
$var reg 8 V r_B [7:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b101000 L
b1010 K
b101000 A
b1010 @
b101000 4
b1010 3
b101000 %
b1010 $
$end
#0
$dumpvars
b0 V
b0 U
b11 T
b0 S
b0 R
b0 Q
b11 P
1O
b0 N
0M
b0 J
b0 I
b0 H
b1000 G
b0 F
b0 E
b0 D
1C
0B
b0 ?
bx >
bx =
bx <
bx ;
bx :
bx 9
08
07
06
05
bx 2
bx 1
00
b101 /
b1000 .
b101 -
b0 ,
b11 +
b101 *
0)
b0 (
b11 '
b101 &
0#
b101 "
0!
$end
#5000
b0 1
b0 :
b0 ;
b0 2
b0 9
b0 >
1M
1B
15
1)
#10000
0M
0B
05
0)
#15000
1M
1B
15
1)
#20000
0M
0B
05
0)
#25000
1M
1B
15
1)
#30000
0M
0B
05
0)
#35000
1M
1B
15
1)
#40000
b11 J
b11 Q
b11 U
b1001001001 ?
b1001001001 F
b1001001001 H
b1000 G
b11 "
b11 -
b11 /
b1 N
b1 S
b11111001 D
b11111001 E
17
b1 (
b1 ,
b1100 .
b1001 &
b1001 *
0M
0B
05
0)
#41000
b1 <
b1 =
16
#45000
b1 1
b1 :
b1 ;
b1 2
b1 9
b1 >
1M
1B
15
1)
#50000
0M
0B
05
0)
#55000
1M
1B
15
1)
#60000
0M
0B
05
0)
#65000
1M
1B
15
1)
#70000
0M
0B
05
0)
#75000
1M
1B
15
1)
#80000
b10100010 "
b10100010 -
b10100010 /
b1100 P
b1100 T
b10 (
b10 ,
b10010001 '
b10010001 +
b10100010 .
b10001 &
b10001 *
0M
0B
05
0)
#81000
06
#85000
1M
1B
15
1)
#90000
0M
0B
05
0)
#95000
1M
1B
15
1)
#100000
0M
0B
05
0)
#105000
1M
1B
15
1)
#110000
0M
0B
05
0)
#115000
1M
1B
15
1)
#120000
b1100 I
b1100 R
b1100 V
b10101 "
b10101 -
b10101 /
1#
b10 N
b10 S
b11 (
b11 ,
b1111100 '
b1111100 +
b100001101 .
b10010001 &
b10010001 *
0M
0B
05
0)
#121000
b10 <
b10 =
16
#125000
b10 1
b10 :
b10 ;
b10 2
b10 9
b10 >
1M
1B
15
1)
#130000
0M
0B
05
0)
#135000
1M
1B
15
1)
#140000
0M
0B
05
0)
#145000
1M
1B
15
1)
#150000
0M
0B
05
0)
#155000
1M
1B
15
1)
#160000
1!
10
b10001101 "
b10001101 -
b10001101 /
b1010 (
b1010 ,
b11111001 '
b11111001 +
b110001101 .
b10010100 &
b10010100 *
0M
0B
05
0)
#161000
06
#165000
1M
1B
15
1)
#170000
0M
0B
05
0)
#175000
1M
1B
15
1)
#180000
0M
0B
05
0)
#185000
1M
1B
15
1)
#190000
0M
0B
05
0)
#195000
1M
1B
15
1)
#200000
0!
00
b1101100 "
b1101100 -
b1101100 /
b1011 (
b1011 ,
b1101001 '
b1101001 +
b100111110 .
b11010101 &
b11010101 *
0M
0B
05
0)
